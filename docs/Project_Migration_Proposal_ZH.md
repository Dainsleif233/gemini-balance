# 项目迁移方案书：Gemini Balance

**版本**: 1.0
**日期**: 2025 年 7 月 13 日
**作者**: Cline，代码迁移专家

---

### 1. 项目主旨与核心价值

**项目主旨**:

`Gemini Balance` 是一个基于 Python FastAPI 构建的高性能、高可用的 AI 网关服务。其核心设计目标是作为 Google Gemini API 的**代理和负载均衡器**。它通过集中管理和智能调度一组 Gemini API 密钥，有效解决了单个密钥固有的速率限制、并发瓶颈和可用性问题。

更进一步，该项目通过内置一个精巧的**适配器层**，实现了对 OpenAI API 格式的完全兼容。这使得它不仅仅是一个 Gemini 的增强工具，更是一个能够无缝融入现有 AI 生态系统的、通用的、可扩展的 AI 服务网关。它允许开发者在不修改任何现有客户端代码的情况下，将底层 AI 服务从 OpenAI 平滑切换到 Gemini，同时享受到本项目带来的负载均衡、故障转移和统一管理等强大功能。

**核心价值**:

- **提升可用性与稳定性**: 通过多 Key 轮询和自动失败重试机制，确保即使部分 Key 失效或达到速率限制，服务依然能够持续、稳定地对外提供。
- **增强并发处理能力**: 将请求分发到多个 Key 上，突破单个 Key 的并发限制，从而支持更大规模的应用场景。
- **降低迁移成本**: 无缝兼容 OpenAI API，使得依赖其生态的现有应用可以零成本、零改造地迁移至 Gemini，或将两者混合使用。
- **提供统一管理视图**: 通过 Web UI 提供可视化的配置管理、密钥状态监控和日志查询功能，极大地简化了运维和问题排查的复杂度。
- **扩展 AI 能力**: 在基础的聊天代理之上，集成了如联网搜索、对话式图像生成、文本转语音（TTS）、Function Calling 等高级功能，为上层应用提供更丰富的能力集。

---

### 2. 核心功能规划与实现

本项目围绕其主旨，规划并实现了一系列核心功能，构成了一个完整的 AI 网关解决方案。

#### 2.1 API 代理与负载均衡

- **功能描述**: 这是项目的基石。它接收外部的 API 请求，并将其智能地转发给上游的 Gemini API 服务。
- **实现能力**:
  - **多 Key 轮询**: 支持在配置中提供一个或多个 Gemini API 密钥。对于每一个新的 API 请求，系统会从有效密钥池中按顺序选择下一个密钥来使用。
  - **自动失败转移与重试**: 当使用某个密钥的请求失败时（例如，密钥失效、网络错误），系统会自动尝试使用下一个可用的密钥进行重试（最多可配置重试次数）。
  - **密钥健康检查与自动禁用/恢复**: 系统会跟踪每个密钥的连续失败次数。当失败次数超过阈值时，该密钥会被自动移入“无效”池中，暂时不再被使用。同时，系统会通过定时任务，定期尝试重新验证这些无效密钥，一旦验证通过，便会自动将其恢复到“有效”池中。

#### 2.2 双协议兼容 (OpenAI & Gemini)

- **功能描述**: 项目的核心亮点之一，能够理解并处理两种主流的 AI API 协议。
- **实现能力**:
  - **原生 Gemini 接口**: 提供 `/v1beta/models/{model}:generateContent` 等原生 Gemini API 端点，完全兼容官方协议。
  - **OpenAI 兼容接口**: 提供 `/v1/chat/completions`, `/v1/embeddings`, `/v1/images/generations` 等与 OpenAI API 完全一致的端点。系统内部会将这些请求的格式（如 `messages` 数组）和参数，智能地转换为 Gemini API 所支持的格式和参数，并将 Gemini 的响应再转换回 OpenAI 的格式返回给客户端。

#### 2.3 高级功能集成

- **功能描述**: 在基础代理之上，通过“衍生模型”和特定服务，为上层应用提供了超越标准 API 的增强能力。
- **实现能力**:
  - **联网搜索**: 当用户请求一个以 `-search` 结尾的特殊模型时（如 `gemini-1.5-pro-search`），系统会在构建请求时自动为其添加 `googleSearch` 工具，从而触发 Gemini 模型的联网搜索能力。
  - **对话式图像生成**: 当用户请求一个以 `-image` 结尾的特殊模型时，系统会调用图像生成服务（如 Google 的 `imagen` 模型），并将生成的图像 URL 包装在聊天消息中返回，实现“你说我画”的交互体验。
  - **Function Calling 适配**: 能够将 OpenAI 格式的 `tools` 参数，转换为 Gemini 支持的 `functionDeclarations`，使得开发者可以在兼容模式下继续使用强大的函数调用功能。
  - **文本嵌入 (Embeddings)**: 提供了兼容 OpenAI 的 `/v1/embeddings` 接口，方便进行文本向量化。
  - **文本转语音 (TTS)**: 提供了兼容 OpenAI 的 `/v1/audio/speech` 接口，可将文本转换为语音。

#### 2.4 可视化管理与监控

- **功能描述**: 提供一个简单易用的 Web UI，方便管理员对系统进行配置和监控。
- **实现能力**:
  - **实时配置**: 管理员可以在 Web 页面上修改绝大部分应用配置（如添加/删除密钥、调整重试次数等），配置可热加载，无需重启服务。
  - **密钥状态监控**: 提供一个仪表盘，实时展示所有 API 密钥的状态（有效/无效）、每个密钥的失败次数、使用统计等关键信息。
  - **日志查询**: 提供错误日志和请求日志的查询界面，方便快速定位和诊断问题。

---

### 3. 核心功能实现方式

本项目的架构清晰，采用了责任分离的设计原则，将复杂的功能分解到不同的服务和处理器中。

#### 3.1 应用启动与生命周期

- **启动入口**: 应用由 `app/main.py` 启动，但核心组装逻辑位于 `app/core/application.py` 的 `create_app` 工厂函数中。
- **生命周期管理**: 采用 FastAPI 的 `lifespan` 上下文管理器来处理应用启动和关闭事件。
  - **启动时**: 依次执行数据库初始化与连接、从 `.env` 同步初始配置到数据库、初始化核心的 `KeyManager` 服务、启动定时任务调度器 (`apscheduler`)。
  - **关闭时**: 安全地停止定时任务调度器，并断开数据库连接。

#### 3.2 密钥管理与负载均衡 (`KeyManager`)

- **核心服务**: `app/service/key/key_manager.py` 中的 `KeyManager` 类是实现负载均衡和故障转移的核心。它被设计为单例模式，在整个应用生命周期中只有一个实例。
- **工作机制**:
  1.  **初始化**: 应用启动时，`KeyManager` 从配置中读取所有 API 密钥，并初始化每个密钥的失败计数器。
  2.  **密钥获取**: 当 API 路由需要密钥时，会调用 `get_next_working_key()` 方法。该方法采用**循环轮询 (Round-Robin)** 策略，遍历内部的有效密钥列表，并返回下一个可用的密钥。
  3.  **失败处理**: API 请求的装饰器 `@RetryHandler` 或服务层逻辑捕获到请求失败后，会调用 `handle_api_failure(api_key)` 方法。该方法会增加对应密钥的失败计数值。
  4.  **自动禁用**: 如果一个密钥的失败计数值超过了预设的 `MAX_FAILURES` 阈值，`KeyManager` 会将其从“有效”列表中移除，放入“无效”列表，从而在后续的轮询中跳过它。
  5.  **自动恢复**: `app/scheduler/scheduled_tasks.py` 中定义的定时任务会周期性地（例如每小时）调用 `KeyManager` 的 `check_and_reactivate_keys` 方法，对“无效”列表中的密钥发起测试请求。如果测试成功，则将其失败计数清零并移回到“有效”列表中，实现自动恢复。

#### 3.3 OpenAI 兼容适配层

这是项目技术实现最精巧的部分，主要由 `app/service/chat/openai_chat_service.py` 及其依赖的处理器 (Handler) 共同完成。

- **请求转换 (`OpenAIMessageConverter`)**:

  - **角色映射**: 将 OpenAI 的 `user`, `assistant` 角色准确映射为 Gemini 的 `user`, `model` 角色。
  - **System Prompt 处理**: 能够从 `messages` 列表中分离出 `system` 角色的消息，并将其放入 Gemini 专用的 `systemInstruction` 字段。
  - **多模态内容转换**: 将 OpenAI 的 `image_url` 格式转换为 Gemini 支持的 `inline_data` 格式。

- **响应转换 (`OpenAIResponseHandler`)**:

  - **结构映射**: 将 Gemini 响应中的 `candidates` 数组和 `usageMetadata` 转换为 OpenAI 的 `choices` 数组和 `usage` 对象。
  - **流式处理**: 对于流式响应，它能处理 Gemini 返回的 Server-Sent Events (SSE)，将每一块数据 (chunk) 都实时转换为 OpenAI 的流式 `ChatCompletionChunk` 格式，并正确处理 `finish_reason`（如 `stop`, `tool_calls`）。
  - **错误处理**: 能够将 Gemini 返回的错误信息包装成一个符合 OpenAI 格式的错误响应。

- **伪流式 (Fake Stream) 实现**:
  - 当针对不支持流式传输的模型开启 `FAKE_STREAM_ENABLED` 时，系统会启动一个后台任务去调用非流式接口。
  - 同时，主任务会通过一个异步生成器，定期向客户端发送空的“心跳”数据块，以保持连接活跃。
  - 当后台任务获取到完整的响应后，再将整个响应作为最后一个数据块发送给客户端，并结束流。

#### 3.4 数据库与日志记录

- **技术栈**: 采用 `SQLAlchemy` 作为 ORM，并结合 `databases` 库实现全异步的数据库操作，支持 `MySQL` 和 `SQLite`。
- **数据模型**: 在 `app/database/models.py` 中定义了 `RequestLog` 和 `ErrorLog` 等数据表。
- **服务化写入**: 在 `app/database/services.py` 中提供了如 `add_request_log` 等服务函数。业务逻辑层（如 `OpenAIChatService`）在处理完请求后，会调用这些服务函数，将请求的详细信息（使用的模型、API Key、延迟、成功与否、状态码等）异步地写入数据库，为数据统计和问题排查提供依据。

---

### 4. 功能暴露方式 (API & UI)

系统通过 RESTful API 和 Web 用户界面 (UI) 两种方式向外暴露其功能，服务于不同角色的用户。

#### 4.1 API 端点 (面向开发者)

API 是提供给开发者或应用程序调用的主要接口，设计上遵循了模块化和版本化的原则。

- **OpenAI 兼容 API**:

  - `POST /v1/chat/completions`: 核心聊天接口。
  - `POST /v1/embeddings`: 文本嵌入接口。
  - `POST /v1/images/generations`: 图像生成接口。
  - `POST /v1/audio/speech`: 文本转语音接口。
  - `GET /v1/models`: 获取模型列表。
  - _注: 同时还支持 `/hf/v1/...` 作为别名路径。_

- **原生 Gemini API**:

  - `POST /v1beta/models/{model}:generateContent`: 原生非流式聊天接口。
  - `POST /v1beta/models/{model}:streamGenerateContent`: 原生流式聊天接口。
  - `GET /v1beta/models`: 获取原生模型列表。
  - _注: 同时还支持 `/gemini/v1beta/...` 作为别名路径。_

- **管理类 API**:
  - `POST /reset-selected-fail-counts`: 重置指定密钥的失败计数。
  - `POST /verify-selected-keys`: 批量验证指定密钥的有效性。
  - _这些 API 主要由前端 UI 调用。_

#### 4.2 Web 用户界面 (面向管理员)

Web UI 是提供给应用管理员进行系统维护和监控的入口，基于 `FastAPI` 的 `Jinja2Templates` 渲染。

- **认证入口 (`/`)**: 所有管理页面的统一登录入口，需要提供在配置中设置的 `AUTH_TOKEN`。
- **配置编辑器 (`/config`)**: 提供一个在线编辑器，允许管理员实时查看和修改应用的配置文件 (`config.py` 中的内容)，修改后可热加载生效。
- **密钥状态仪表盘 (`/keys`)**: 核心监控页面，以列表形式展示所有密钥的当前状态（有效/无效）、失败次数、使用统计等，并提供手动验证、重置计数等操作按钮。
- **日志查看器 (`/logs`)**: 提供错误日志的在线查看功能，支持分页和搜索，方便管理员快速排查线上问题。

#### 4.3 Web UI 管理功能详解

Web UI 是管理员与系统交互的核心，其设计旨在提供直观、实时的系统洞察与控制能力。下面将详细拆解主要管理功能的工作流。

**1. 密钥状态管理 (Key Status Dashboard - `/keys`)**

- **功能描述**: 这是最核心的监控页面，提供对所有 API 密钥健康状况的全面视图和管理能力。
- **数据获取**:
  - 当管理员访问 `/keys` 页面时，后端的页面路由函数 (`app/router/routes.py` 中的 `keys_page`) 会被触发。
  - 该函数会调用 `KeyManager` 服务的 `get_keys_by_status()` 方法，从内存中获取实时分类的有效和无效密钥列表及其失败计数。
  - 同时，它会调用 `StatsService` 的 `get_api_usage_stats()` 方法，从数据库中聚合统计数据（如总请求数、成功率等）。
  - 这些数据被整合后，传递给 `keys_status.html` 模板进行渲染，最终呈现给管理员。
- **操作与反馈**:
  - **操作方式**: 页面上的“验证密钥”、“重置计数”等按钮，会通过前端 JavaScript (`app/static/js/keys_status.js`) 向后端的特定管理 API (定义于 `app/router/gemini_routes.py`，如 `/verify-selected-keys`, `/reset-selected-fail-counts`) 发起异步 `fetch` 请求。
  - **结果反馈**: 后端 API 处理完请求后，会返回一个 JSON 对象，其中包含操作结果（`success: true/false`）和提示信息（`message`）。前端 JS 接收到这个 JSON 响应后，会通过弹窗（Toast/Alert）向管理员显示操作结果，并重新请求密钥列表数据以刷新界面。
- **对系统的影响**:
  - **重置计数**: 调用此功能会直接修改 `KeyManager` 内存中对应密钥的失败计数值为 0，并可能将其从“无效”列表移回“有效”列表。**效果是立竿见影的**，该密钥会立刻被纳入下一次 API 请求的轮询池中。
  - **验证密钥**: 此操作会触发一次对上游 Gemini API 的真实测试请求。如果成功，其效果等同于重置计数；如果失败，则会增加其失败计数，可能导致该密钥被移入“无效”列表。

**2. 动态配置管理 (Config Editor - `/config`)**

- **功能描述**: 提供一个在线文本编辑器，允许管理员直接修改应用的配置参数。
- **数据获取与操作**:
  - **获取**: 访问 `/config` 页面时，前端 JS (`app/static/js/config_editor.js`) 会向后端 API (`/api/config/load`) 发起请求。后端 `ConfigService` 会读取数据库中存储的配置项，并以 JSON 格式返回给前端，填充到编辑器中。
  - **保存**: 管理员修改后点击保存，前端 JS 会将编辑器中的全部内容 POST 到后端 API (`/api/config/save`)。后端 `ConfigService` 负责解析、验证并更新数据库中的配置项。
- **结果反馈**: 保存操作的 API 会返回操作成功或失败的 JSON 信息，前端同样以弹窗形式提示用户。
- **对系统的影响**:
  - 配置保存成功后，后端服务会**热加载 (Hot-reload)** 新的配置。例如，如果修改了 `MAX_RETRIES`（最大重试次数），那么后续的所有 API 请求将立刻采用新的重试次数，**无需重启整个应用服务**。这是一个非常强大的功能，大大提升了系统的可维护性。

**3. 日志中心 (Log Center - `/logs`)**

- **功能描述**: 提供一个集中的界面来查询和浏览应用运行过程中产生的错误日志。
- **数据获取**:
  - 页面 (`error_logs.html`) 加载时，其关联的 JS (`app/static/js/error_logs.js`) 会向后端 API (`/api/error-logs`) 发起请求，获取第一页的日志数据。
  - 用户进行分页或搜索操作时，会触发新的 API 请求，并将分页参数（`page`, `size`）或搜索关键词作为查询参数传递给后端。
  - 后端 `ErrorLogService` 会根据这些参数，执行相应的数据库查询，并将结果以 JSON 格式返回。
- **操作与反馈**:
  - **删除日志**: 点击删除按钮会向后端 `/api/error-logs/{log_id}` 发送一个 `DELETE` 请求。后端处理后返回成功信息，前端则从界面上移除对应的日志条目。
- **对系统的影响**: 日志中心的查询和删除操作仅与数据库中的历史记录交互，**不会对正在处理的实时 API 请求或系统的核心负载均衡逻辑产生任何影响**。它是一个纯粹的、用于事后分析和排错的观测工具。

---

### 5. 用户使用指南

#### 5.1 开发者 (API 使用者)

1.  **获取访问凭证**: 从管理员处获取一个被允许访问的 `ALLOWED_TOKENS`。
2.  **配置客户端**: 在您现有的 OpenAI 客户端代码中，进行以下两项修改：
    - 将 API 的 `base_url` 指向本服务的地址，例如 `http://your-service-ip:8000/v1`。
    - 将 `api_key` 设置为您获取到的访问凭证。
3.  **发起请求**: 正常调用客户端的各种方法（如 `client.chat.completions.create(...)`）。所有请求将自动通过本服务进行代理和负载均衡。
4.  **使用高级功能**:
    - **联网搜索**: 请求模型时，在模型名称后添加 `-search` 后缀，例如 `gemini-1.5-pro-search`。
    - **对话生图**: 请求模型时，使用特定的图像生成模型名称，例如 `imagen-3.0-generate-002-chat`。

#### 5.2 管理员 (系统维护者)

1.  **部署服务**: 参考 `README.md`，使用 Docker 或本地源码方式启动服务。核心是准备好 `.env` 文件，填入数据库信息、Gemini API 密钥列表 (`API_KEYS`) 和管理员认证令牌 (`AUTH_TOKEN`)。
2.  **访问后台**: 打开浏览器，访问 `http://your-service-ip:8000`。
3.  **登录**: 在认证页面输入您在 `.env` 中配置的 `AUTH_TOKEN`。
4.  **日常监控**:
    - 定期访问 `/keys` 页面，关注密钥的健康状况，对于长期无效的密钥及时处理。
    - 访问 `/logs` 页面，检查是否有异常错误。
5.  **配置变更**:
    - 访问 `/config` 页面，可以直接修改配置。例如，当您获取到新的 Gemini API 密钥时，可以直接在 `API_KEYS` 列表中添加，然后点击保存即可生效，无需重启服务。

---

### 6. 辅助及附加功能

除了上述核心功能，项目还包含一系列辅助功能以提升其健壮性和用户体验。

- **流式输出优化器**: 对流式响应的文本输出进行智能缓冲和分块，优化打字机效果，避免因网络抖动或模型输出速度不均导致的卡顿。
- **健康检查端点 (`/health`)**: 提供一个简单的 `/health` 接口，方便集成到各类监控系统（如 K8s 的 liveness probe）中，实现对服务存活状态的自动化监控。
- **版本更新检查**: 应用启动时会自动检查 GitHub 仓库是否有新版本发布，并在管理界面的 UI 中进行提示，方便管理员及时了解项目动态。
- **数据库自动迁移**: 应用启动时会检查数据库表结构是否存在，如果不存在，则会自动根据 `SQLAlchemy` 的模型定义创建相应的表。
- **日志自动清理**: 支持配置定时任务，自动删除指定天数之前的旧日志（请求日志和错误日志），防止数据库无限膨胀。

---

### 7. 状态管理与数据持久化

为了保证服务的高可用和可观测性，项目对状态和运行时数据进行了精细的管理，结合了内存实时状态和数据库持久化存储。

#### 7.1 内存状态管理 (In-Memory State)

应用的核心动态数据，特别是与负载均衡直接相关的部分，被存储在内存中以保证最低的访问延迟。

- **核心组件**: `app/service/key/key_manager.py` 中的 `KeyManager` 单例服务。
- **管理的数据**:
  - **密钥状态**: `KeyManager` 内部维护着“有效密钥”和“无效密钥”两个列表。
  - **失败计数**: 为每个 API 密钥维护一个实时的失败计数值。
- **状态变更时机**:
  - **请求失败时**: 当一个 API 请求失败，对应的密钥失败计数会增加。如果超过阈值，该密钥会从“有效”列表移动到“无效”列表。
  - **定时任务执行时**: 后台的定时任务会定期检查“无效”密钥。如果某个密钥恢复正常，它将被移回“有效”列表，并且其失败计数被清零。
- **特点**: 这种内存状态管理方式响应速度极快，能够实时地对 API 密钥的健康状况做出反应，但缺点是应用重启后状态会丢失，需要通过初始化流程重建。

#### 7.2 运行数据持久化

对于需要长期保存、用于分析和排错的数据，项目采用了数据库进行持久化存储。

- **技术栈**: 使用 `SQLAlchemy` ORM 和 `databases` 库，以异步方式操作数据库，支持 `MySQL` 和 `SQLite`。
- **持久化的数据**:
  1.  **请求日志 (`RequestLog`)**: 记录每一次 API 调用的元数据。
  2.  **错误日志 (`ErrorLog`)**: 记录所有失败的 API 请求的详细错误信息。
  3.  **应用配置 (`Settings`)**: 将 `.env` 中的部分配置同步到数据库，以支持通过管理界面进行热更新。

#### 7.3 数据写入与清理机制

- **数据写入时机与方法**:

  - **请求/错误日志**:
    - **时机**: 在每个 API 请求处理**完成之后**（无论成功或失败），在 `finally` 或 `except` 块中触发。
    - **方法**: 业务逻辑层（如 `OpenAIChatService`）会调用 `app/database/services.py` 中提供的异步服务函数（如 `add_request_log`, `add_error_log`），将日志数据写入数据库。这种异步写入的方式确保了日志记录不会阻塞主请求的处理流程。
    - **存入内容**:
      - **请求日志**: 包括调用的模型、使用的 API 密钥（部分屏蔽）、是否成功、HTTP 状态码、请求延迟（毫秒）、请求时间等。
      - **错误日志**: 包括使用的 API 密钥、模型名称、错误类型、详细的错误堆栈信息、HTTP 状态码以及原始的请求体（payload）。
  - **应用配置**:
    - **时机**: 应用首次启动时，以及管理员在 UI 上点击保存配置时。
    - **方法**: 通过 `ConfigService` 将配置项以键值对的形式存入 `Settings` 表。

- **冗余数据清理**:
  - **机制**: 通过 `app/scheduler/scheduled_tasks.py` 中配置的 `APScheduler` 定时任务实现。
  - **触发条件**: 根据 `.env` 文件中的 `AUTO_DELETE_..._ENABLED` 和 `AUTO_DELETE_..._DAYS` 配置项。如果启用了自动删除，定时任务会每天执行一次。
  - **执行逻辑**: 任务会执行一个数据库删除操作，清除掉 `RequestLog` 和 `ErrorLog` 表中时间戳早于配置天数的记录，从而有效控制数据库的大小，防止日志数据无限增长。
